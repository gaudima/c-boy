//
// Created by gaudima on 21.01.2016.
//

#include "mmu.h"
#include "cpu.h"
#include "gpu.h"
#include "joy.h"
#include "mbc/nombc.h"
#include "mbc/mbc1.h"
#include "mbc/mbc2.h"
#include <fstream>

Emu::Mmu::Mmu(Emu *emu):
bios {0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
      0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
      0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
      0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
      0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
      0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
      0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
      0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
      0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
      0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
      0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
      0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
      0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
      0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
      0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
      0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50}
{
    this->emu = emu;
    mbc = NULL;
    reset();
}

void Emu::Mmu::reset() {
    bios_loaded = false;

    rom = Mmu::ram;
    //vram = Mmu::ram + 0x8000;
    //eram = Mmu::ram + 0xA000;
    wram = Mmu::ram + 0xC000;
    wramsh = Mmu::ram + 0xE000;
    //spinfo = Mmu::ram + 0xFE00;
    //mmio = Mmu::ram + 0xFF00;
    //zram = Mmu::ram + 0xFF80;

    if(mbc != NULL) {
        delete mbc;
    }
    mbc = NULL;
    for(int i = 0; i < 0xFFFF; i++) {
        ram[i] = 0;
    }
}

Emu::Mmu::~Mmu() {
    if(mbc != NULL) {
        delete mbc;
    }
}

uint8_t Emu::Mmu::rb(uint16_t addr) {
    if(!bios_loaded && addr < 0x0100) {
        return Mmu::bios[addr];
    } else if(emu->cpu->r.pc == 0x0100){
        bios_loaded = true;
    }
    if(addr == 0xFF00) {
        return emu->joy->getJoypadState();
    }
    return rbu(addr);
}

uint16_t Emu::Mmu::rw(uint16_t addr) {
    return (rb(addr + 1)<<8) + (rb(addr));
}

uint8_t Emu::Mmu::rbu(uint16_t addr) {
    if((0x0000 <= addr && addr <= 0x7FFF) || (0xA000 <= addr && addr <= 0xBFFF)) {
        return mbc->rb(addr);
    }
    return ram[addr];
}

uint16_t Emu::Mmu::rwu(uint16_t addr) {
    return (rbu(addr + 1)<<8) + (rbu(addr));
}

void Emu::Mmu::wb(uint16_t addr, uint8_t val) {
//    if(addr < 0x8000) {
//        return;
//    }
    if(addr == 0xFF07) {
        uint8_t oldFreq = (rb(addr) & 0x03);
        wbu(addr, val);
        uint8_t newFreq = (val & 0x03);
        if(oldFreq != newFreq) {
            emu->cpu->setTimerFreq();
        }
    }
    if(addr == 0xFF04 || addr == 0xFF44) {
        wbu(addr, 0);
    } else {
        wbu(addr, val);
    }
    if(0x8000 <= addr && addr <= 0x97FF) {
        emu->gpu->updateTile(addr, val);
    }
    if(addr == 0xFF46) {
        processDMATransfer(val);
    }
}

void Emu::Mmu::ww(uint16_t addr, uint16_t val) {
    wb(addr, val & 0xFF);
    wb(addr + 1, val >> 8);
}

void Emu::Mmu::wbu(uint16_t addr, uint8_t val) {
    if((0x0000 <= addr && addr <= 0x7FFF) || (0xA000 <= addr && addr <= 0xBFFF)) {
        mbc->wb(addr, val);
        return;
    }
    if(0xC000 <= addr && addr <= 0xDE00) {
        wramsh[addr - 0xC000] = val;
    }
    if(0xE000 <= addr && addr <= 0xFE00) {
        wram[addr - 0xE000] = val;
    }
    ram[addr] = val;
}
void Emu::Mmu::wwu(uint16_t addr, uint16_t val) {
    wbu(addr, val & 0xFF);
    wbu(addr + 1, val >> 8);
}

void Emu::Mmu::loadRom(std::string filename) {
    if(mbc != NULL) {
        delete mbc;
    }
    std::ifstream in(filename, std::ios::in | std::ios::binary);
    std::streampos romSize = in.tellg();
    in.seekg(0, std::ios::end);
    romSize = in.tellg() - romSize;
    uint8_t *fullRom = new uint8_t[romSize];
    in.seekg(0, std::ios::beg);
    in.read((char*)fullRom, romSize);
    in.close();
    std::cout << std::dec << romSize / 0x4000 << std::endl;
    uint8_t ramBanks;
    switch(fullRom[0x0149]) {
        case 0:
        case 1:
        case 2:
            ramBanks = 1;
            break;
        case 3:
            ramBanks = 4;
            break;
        case 4:
            ramBanks = 16;
    }
    switch(fullRom[0x0147]) {
        case 0:
            mbc = new NoMbc(fullRom, romSize / 0x4000, new uint8_t[ramBanks * 0x2000], ramBanks);
            break;
        case 1:
        case 2:
        case 3:
        case 4:
            mbc = new Mbc1(fullRom, romSize / 0x4000, new uint8_t[ramBanks * 0x2000], ramBanks);
            break;
        case 5:
        case 6:
            mbc = new Mbc2(fullRom, romSize / 0x4000, new uint8_t[ramBanks * 0x2000], ramBanks);
            break;
    }
    //std::cout<<std::hex<<(int)ram[0]<<std::endl;
}

void Emu::Mmu::processDMATransfer(uint8_t data) {
    uint16_t adress = data << 8;
    for(uint8_t i = 0; i < 0xA0; i++) {
        emu->mmu->wb(0xFE00 + i, emu->mmu->rb(adress + i));
    }
    emu->gpu->updateSpritePriority();
}